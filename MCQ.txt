1.What is the output?

      String k ="big "; 
      k.concat("crowded ");
      k += "city";
      System.out.println(k);

1). compile error
2). big crowded city
3). big crowded
4). big city
Solution :
option [4] is correct



2.class Atom { 
             Atom() { 
        System.out.print("atom "); 
} 
 }
//////////////////////
class Rock extends Atom { 
Rock(String type) { 
System.out.print(type); 
} 
}
//////////////////////

public class Mountain extends Rock { 
Mountain() { 
super("granite "); 
new Rock("granite "); 
} 
public static void main(String[] a) { 
new Mountain(); 
} 
}

What will be the result?

1). Compilation fails.
2). atom granite
3). atom granite atom granite
4). atom granite granite
Solution :
option [3] is correct
Attempted :
option [1] is attempted

3.What will be the output?

  public class Test {
     public static void main(String[] args) {
        try {
            badMethod();
            System.out.print("E");
            return;
        } catch (RuntimeException ex) {
            System.out.print("B");
        } catch (Exception ex1) {
            System.out.print("C");
        } finally {
            System.out.print("D");
        }
    }
    public static void badMethod() {
        System.out.print("A");
    }
 }

1). AED
2). ABD
3). AE
4). Compilation Error
Solution :
option [1] is correct
Attempted :
option [1] is attempted

4.The following code :

public class Test {
    public static void main(String[] args) {
    int a=5, b=7;
    if(a & b > 0 && a | b > 0)
        System.out.println("true");
    else
        System.out.println("false");
    }
}

1). prints output true
2). No output.
3). does not compile
4). runtime exception
Solution :
option [3] is correct

5.public class Test {
    public static void main(String[] args) {
        int n = 1;
        outer :
        while (n < 6) {
            for (int i = 0; i < 10; i++) {
                if (i % 2 == 0) {
                    System.out.print(i + " ");
                    continue;
                } else {
                    System.out.print(n + " ");
                    break outer;
                }
            }
            n++;
        }
    }
}

1). 0 2 4 6 7 1
2). 0 1 0 1 0 1 0 1 0 1
3). 0 1
4). compile Erorr
Solution :
option [3] is correct

6.What is the output for the following?

   public class Test {
      public static void main(String [] args) {
         short a, b, c=0;
         a=1;
         b=2;
         c=a+b;
         System.out.println(c);
      }
  }

1). Compile error.
2). 3
3). 1
4). runtime exception
Solution :
option [1] is correc
7.Which two code fragments, inserted independently at line 3, generate the output 4247? (Choose two.)

1.public class TestString3 { 
2.      public static void main(String[] args) { 
3.              // insert code here 
4.            System.out.println(s); 
5.      } 
6. }

1). String s = "123456789"; s = (s-"123").replace(1,3,"24") - "89";
2). StringBuffer s = new StringBuffer("123456789"); s.delete(0,3).replace(1,3,"24").delete(4,6);
3). StringBuffer s = new StringBuffer("123456789"); s.substring(3,6).delete(1,3).insert(1, "24");
4). StringBuilder s = new StringBuilder("123456789"); s.substring(3,6).delete(1,2).insert(1, "24");
5). StringBuilder s = new StringBuilder("123456789"); s.delete(0,3).delete(1,3).delete(2,5).insert(1, "24");
Solution :
option [2,5] are correct

8.What will be the output?

     String[][] names = {
                 {"Mr.", "Mrs.", "Ms."},
                 {"John", "Gupta", "Hegde", "Khan"},
                 {":M", ":F"}
               };
     System.out.println(names[0][2] + names[1][2]+ names[2][1]);

1). Compile error
2). Mrs.Gupta : M
3). Ms.Hegde : F
4). Mr.Khan : M
Solution :
option [3] is correct

9.What will be the output?

public class Test_1 {
    static String str;
       public static void main(String[] args) {
        String s;
        if(str=="abc")
           s = str+10;
        System.out.println(str);
        System.out.print(s);
       }
}

1). null and null are printed as output.
2). runtime error.
3). Compile error, cannot access str from main.
4). Compile error, s not initialised.
Solution :
option [4] is correct

10.Which two classes inherit the Shape class correctly?

public abstract class Shape { 
private int x; 
private int y; 
public abstract void draw(); 
public void setAnchor(int x, int y) { 
this.x = x; this.y = y; 
} 
              }

1). public class Circle implements Shape { private int radius; }
2). public abstract class Circle extends Shape { private int radius; }
3). public class Circle extends Shape { private int radius; public void draw(); }
4). public abstract class Circle implements Shape { private int radius; public void draw(); }
5). public class Circle extends Shape {
private int radius; public void draw() {/* code here */} }
Solution :
option [2,5] are correct

11.Which of the following is true?

 A. An interface cannot be instantiated.
 B. A final field of a class can be instantiated in the constructor. 
 C. A protected field of a class is accessible by child class in any package.
 D. A class can implement more than one interface

1). A & D
2). A, C & D
3). A, B &D
4). All of them
Solution :
option [4] is correct

12.What will be the result?

class TestModifiers{
         int i;
         public static void main (String[] args) {
                   int i; //1
                  private int a = 1; //2
                  protected int b = 1; //3
                  public int c = 1; //4
                  System.out.println(a+b+c); //5
         }
}

1). compiletime error at line 1,2,3,4,5;
2). compiletime error at line 2,3,4,5;
3). compiletime error at line 2,3,4;
4). Prints 3
5). None of the above
Solution :
option [2] is correct

13.What will be the result?

class TestModifiers{
         int i;
         public static void main (String[] args) {
                   int i; //1
                  private int a = 1; //2
                  protected int b = 1; //3
                  public int c = 1; //4
                  System.out.println(a+b+c); //5
         }
}

1). compiletime error at line 1,2,3,4,5;
2). compiletime error at line 2,3,4,5;
3). compiletime error at line 2,3,4;
4). Prints 3
5). None of the above
Solution :
option [2] is correct

14.What will be the result?

public class Yippee { 
        public static void main(String [] args) { 
                for(int x = 1; x < args.length; x++) { 
                        System.out.print(args[x] + " "); 
                } 
        } 
}
and two separate command line invocations: 
        java Yippee 
        java Yippee 1 2 3 4 

1). No output is produced. 1 2 3
2). No output is produced. 2 3 4
3). No output is produced. 1 2 3 4
4). An exception is thrown at runtime. 1 2 3
5). An exception is thrown at runtime. 2 3 4
6). An exception is thrown at runtime. 1 2 3 4
Solution :
option [2] is correct

15.Which statement is true?

1). A class's finalize() method CANNOT be invoked explicitly. 
2). super.finalize() is called implicitly by any overriding finalize() method. 
3). The finalize() method for a given object is called no more than once by the garbage collector. 
4). The order in which finalize() is called on two objects is based on the order in which the two objects 
became finalizable.
Solution :
option [3] is correct

16.What is the output if main() is run?

public abstract class Vehicle {
 private int tyres;
 public void setTyres(int tyres) {
   this.tyres = tyres;
 } 
 public int getTyres() {
   return tyres;
 } 
}
public class Car extends Vehicle {
  @Override
  public int getTyres() {
     return super.getTyres()+1;
  } 
}
public class Main {
  public static void main(String args[]) {
    Car c = new Car(); 
    c.setTyres(5); 
    System.out.println("Tyres = "+c.getTyres()); 
  }
}

1). Tyres = 5
2). compilation error
3). Tyres = 6
4). runtime exception
Solution :
option [2] is correct

17.1. interface Foo {} 
2. class Alpha implements Foo {} 
3. class Beta extends Alpha {} 
4. class Delta extends Beta { 
5. public static void main( String[] args ) { 
6.        Beta x = new Beta(); 
7.       // insert code here Line 7.
8.  } 
9. }

Which code, inserted at line 7., will cause a java.lang.ClassCastException?

1). Alpha a = x;
2). Foo f = (Delta)x;
3). Foo f = (Alpha)x;
4). Beta b = (Beta)(Alpha)x;
Solution :
option [2] is correct

18.Given:

1. static void test() throws RuntimeException { 
2. try { 
3. System.out.print("test "); 
4. throw new RuntimeException(); 
5. } 
6. catch (Exception ex) { System.out.print("exception "); } 
7. } 
8. public static void main(String[] args) { 
9. try { test(); } 
10. catch (RuntimeException ex) { System.out.print("runtime "); } 
11. System.out.print("end "); 
12. } 

What will be the result?

1). test ends
2). compilation error
3). test runtime end
4). test exception end
5). A Throwable is thrown by main at runtime.
Solution :
option [4] is correct

19.The following code :

public class Test{ 
  public static void main(String args[]) {
    B b = new B();
  }
}
class A {
  A() {
    System.out.print("A");
  }
}
class B extends A{
  B() {
    System.out.print("B");
  }
}

1). Gives output : BA
2). Gives output : AB
3). Gives output : B
4). Compilation Error
Solution :
option [2] is correct



1. Given:

public class Concert {
static class PowerOutage extends Exception {}
static class Thunderstorm extends Exception {}
public static void main(String[] args) {
try {
new Concert().listen();
System.out.println("a");
} catch(PowerOutage | Thunderstorm e) {
e = new PowerOutage();
System.out.println("b");
} finally { System.out.println("c"); }
}
public void listen() throws PowerOutage, Thunderstorm{ }
}

What will this code print?

1). a
2). ab
3). ac
4). abc
5). compilation error
Solution :
option [5] is correct

2. Refer the given code :

public class Test {
public static void main(String... args) {

Set s = new TreeSet();
 s.add("7");
 s.add(9);
 Iterator itr = s.iterator();
 while (itr.hasNext())
 System.out.print(itr.next() + " ");
}
}

1). Compile error
2). Runtime Exception
3). 7 9
4). None of the above
Solution :
option [2] is correct

3.Which code, inserted at line 4, guarantees that this program will output [1, 2]?

1. import java.util.*;
2. public class Example {
3. public static void main(String[] args) {
4. // insert code here
5. set.add(new Integer(2));
6. set.add(new Integer(1));
7. System.out.println(set);
8. }
9. }

1). Set set = new TreeSet();
2). Set set = new HashSet();
3). Set set = new SortedSet();
4). List set = new SortedList();
5). Set set = new LinkedHashSet();
Solution :
option [1] is correct

4.Given: 

1. public static Collection get() { 
2.          Collection sorted = new LinkedList(); 
3.          sorted.add("B"); sorted.add("C"); sorted.add("A"); 
4.          return sorted; 
5. } 
6. public static void main(String[] args) { 
7.          for (Object obj: get()) { 
8.                    System.out.print(obj + ", "); 
9.          } 
10. } 

What is the result?

1). A,B,C
2). B,C,A
3). Compilation Fails
4). The code runs without output
5). Exception thrown
Solution :
option [2] is correct

5.Given: 

1. public static Collection get() { 
2.          Collection sorted = new LinkedList(); 
3.          sorted.add("B"); sorted.add("C"); sorted.add("A"); 
4.          return sorted; 
5. } 
6. public static void main(String[] args) { 
7.           Collection list = get();
7.          for (Object obj: list) { 
8.                    System.out.print(obj + ", "); 
9.          } 
10. } 

What is the result?

1). A, B, C
2). B, C, A
3). Compilation fails. 
4). The code runs with no output. 
Solution :
option [2] is correct

6.Which of the following are true statements?

1). The Iterator interface declares only three methods: hasNext, next and remove.
2). The ListIterator interface extends both the List and Iterator interfaces.
3). The ListIterator interface provides forward and backward iteration capabilities.
4). The ListIterator interface provides the ability to modify the List during iteration.
5). The ListIterator interface provides the ability to determine its position in the List.
Solution :
option [1,3,4,5] are correct
Attempted :

7.Which statements creates an ArrayList of Strings with an initial capacity of 20? 
(Choose all that apply)

1). ArrayList<String> names = new ArrayList<>( );
2). ArrayList<String> names = new ArrayList<>(20);
3). ArrayList<String> names = new ArrayList<String>( );
4). ArrayList<String> names = new ArrayList<String>(20);
Solution :
option [2,4] are correct

8.Given the code fragment:

public static vodi main(String args[]){
ArrayList<String> list= new ArrayList<>();
list.add("SE");
list.add("EE");
list.add("ME");
list.add("SE");
list.add("EE");

list.remove("SE");
System.out.println("Values are : "+ list);
}

1). [ SE,EE,ME,EE]
2). [ EE ME SE EE ]
3). [ SE SE EE, EE]
4). [EE ME EE]
Solution :
option [2] is correct

9.What, inserted at line 39, will sort the keys in the props HashMap?

34. HashMap props = new HashMap(); 
35. props.put("key45", "some value"); 
36. props.put("key12", "some other value"); 
37. props.put("key39", "yet another value"); 
38. Set s = props.keySet(); 
39. // insert code here

1). Arrays.sort(s);
2). s = new TreeSet(s);
3). Collections.sort(s);
4). s = new SortedSet(s);
Solution :
option [2] is correct

10. Identify 2 benefits of using ArrayList over array in Software Development.

1). reduces memory footprint
2). implements Collection API
3). is multithread safe
4). dynamically resizes based on the number of elements in the list
Solution :
option [1,4] are correct

11.If we do:

ArrayList lst = new ArrayList();

What is the initial capacity of the ArrayList lst ?

1). 10
2). 8
3). 15
4). 12
Solution :
option [1] is correct

12.
Which line of code marks the earliest point that an object referenced by intObj becomes 
a candidate for garbage collection?

11. public void genNumbers() {
12. ArrayList numbers = new ArrayList();
13. for (int i=0; i<10; i++) {
14. int value = i * ((int) Math.random());
15. Integer intObj = new Integer(value);
16. numbers.add(intObj);
17. }
18. System.out.println(numbers);
19. }

1). Line 16
2). Line 17
3). Line 18
4). Line 19
5). The object is NOT a candidate for garbage collection.
Solution :
option [4] is correct

13.Given the following code:

package test;
import java.util.ArrayList;
public class Roller {
public static void main(String[] args) {
ArrayList<String> collector = new ArrayList<String>( );
collector.add("Study");
collector.add(Integer.toOctalString(Integer.MAX_VALUE));
ArrayList<String> names = new ArrayList<>( );
names.addAll(collector);
names.add("Study");
names.add(null);
System.out.println(names.size( ));
}
}

What is printed on the console?

1). 0
2). 2
3). 3
4). 4
Solution :
option [4] is correct

14.View the Exhibit.
public class Hat {
public int ID =0;
public String name = "hat";
public String size = "One Size Fit All";
public String color="";
public String getName() { return name; }
public void setName(String name) {
this.name = name;
}
}
Given
public class TestHat {
public static void main(String[] args) {
Hat blackCowboyHat = new Hat();
}
}

Which statement sets the name of the Hat instance?

1). blackCowboyHat.setName = "Cowboy Hat";
2). setName("Cowboy Hat");
3). Hat.setName("Cowboy Hat");
4). blackCowboyHat.setName("Cowboy Hat");
Solution :
option [4] is correct

15.
Given a pre-generics implementation of a method:

11. public static int sum(List list) { 
12. int sum = 0; 
13. for ( Iterator iter = list.iterator(); iter.hasNext(); ) { 
14. int i = ((Integer)iter.next()).intValue(); 
15. sum += i; 
16. } 
17. return sum; 
18. } 

Which three changes must be made to the method sum to use generics? (Choose three.)

1). Remove line 14.
2). Replace line 13 with "for (int i : intList) {".
3). Replace line 13 with "for (Iterator iter : intList) {".
4). Replace the method declaration with "sum(List<int> intList)".
5). Replace the method declaration with "sum(List<Integer> intList)"
Solution :
option [1,2,5] are correct

16.What is the output for the below code?

import java.util.Iterator;
import java.util.TreeSet;
public class Test {
public static void main(String... args) {

TreeSet s1 = new TreeSet();
s1.add("one");
s1.add("two");
s1.add("three");
s1.add("one");
 Iterator it = s1.iterator();
 while (it.hasNext() ) {
 System.out.print( it.next() + " " );
 }
}
}

1). one three two
2). Runtime Exception
3). one three two one
4). one two three
Solution :
option [1] is correct


17.Refer the code below:

import java.util.ArrayList;
 import java.util.List;
 public class Test{ 
       public static void main(String args[]) {
        List<Integer> list = new ArrayList<Integer>(); 
    list.add(0, 59);
    int total = list.get(0);
    System.out.println(total);  
     }
}

1). Gives output : 0
2). Will not compile
3). Gives output : 59
4). Runtime Exception
Solution :
option [3] is correct

18.
Given the code fragment:

1. ArrayList<Integer> list = new ArrayList<>(1);
2. list.add(1001);
3. list.add(1002);
4. System.out.println(list.get(list.size()));

What is the result?

1). Compilation fails due to an error on line 1.
2). An exception is thrown at run time due to error on line 3
3). An exception is thrown at run time due to error on line 4
4). 1002
Solution :
option [3] is correct


19.What is the result?

1. import java.util.*;
2.
3. public class LetterASort{
4. public static void main(String[] args) {
5. ArrayList<String> strings = new ArrayList<String>();
6. strings.add("aAaA");
7. strings.add("AaA");
8. strings.add("aAa");
9. strings.add("AAaa");
10. Collections.sort(strings);
11. for (String s : strings) { System.out.print(s + " "); }
12. }
13. }

1). Compilation fails.
2). aAaA aAa AAaa AaA
3). AAaa AaA aAa aAaA
4). AaA AAaa aAaA aAa
5). aAa AaA aAaA Aaaa
Solution :
option [3] is correct


20.

Whats is the output?

import java.util.ArrayList;
import java.util.List;
public class Test {     
      public static void main(String[] args) {
           List<String> list = new ArrayList<>();
           list.add("English");
           list.add("Hindi");
           list.add("Kannada");
           list.add("Marathi");
           list.add("Tamil");
           list.add("Telugu");
           list.add(2,"Oriya");
           System.out.print(list.get(4));
           list.remove(3);
           System.out.print(list.get(4));
      }
}

1). TamilTelugu
2). KannadaMarathi
3). MarathiTamil
4). Exception at runtime
Solution :
option [3] is correct


1.Which of the given options is most appropriate for line 3 ? 
Assume sequence exists in the database
......
String sql="SELECT empseq.nextval FROM dual";
  Statement stmt = con.createStatement();
  ResultSet rSet = stmt.executeQuery(sql);
  //line 3
  return rSet.getInt(1);

1). while(rSet.next()
2). if(rSet.next())
3). for(rSet.next())
4). No statement is required
Solution :
option [2] is correct

2.Which of the following are true about execute method of Statement/PreparedStatement?

1). It is used to execute DDLcommands
2). It is used to execute DMLcommands
3). The return type of this method is boolean
4). The return type of this method is int
Solution :
option [1,3] are correct

3.Which of the following lines in JDBC 4.0 are optional?

1). Instantiating the database driver class
2). Registering / Loading the driver with DriverManager
3). Establishing connection using DriverManager
4). Providing the location of database driver jar file
Solution :
option [1,2] are correct

4.JDBC functionality offered by java.sql package depicts which of the following features?

1). Polymorphism
2). Programming to interface
3). Inheritance
4). Vendor independence
5). All of the above
Solution :
option [5] is correct

5.ResultSet.TYPE_SCROLL_INSENSITIVE means ?

1). ResultSet is insensitive to scrolling
2). Resultset is sensitive to scrolling, but insensitive to updates, i.e. not updateable
3). ResultSet is sensitive to scrolling, but insensitive to changes made by others
4). Depends on the type of data source, and the type and version of the driver you use with 
this data source
Solution :
option [3] is correct

6.Consider the following code and choose the right java code to call this procedure:

CREATE OR REPLACE PROCEDURE updateSeats(show VARCHAR2,numOfSeats NUMBER,status OUT VARCHAR2) AS
BEGIN
UPDATE ShowDetails SET AvSeats=numOfSeats WHERE ShowId=show;
IF SQL%FOUND  THEN 
status:='true';
ELSE
status:='false';
END IF;
END;
/

1). CallableStatement cst = 
conn.prepareCall
("{call updateSeats(?,?,?)}");
cst.setString(1, "S101");
cst.setInt(2,30);
cst.registerOutParameter(3, Types.VARCHAR);
cst.execute();
String seatsUpdated = cst.getString(3);
System.out.println("Seats updated :" + seatsUpdated);
2). Statement cst = 
conn.prepareStatement
("{call updateSeats(?,?,?)}");
cst.setString(1, "S101");
cst.setInt(2,30);
cst.registerOutParameter(3, Types.VARCHAR);
cst.execute();
String seatsUpdated = cst.getString(3);
System.out.println("Seats updated :" + seatsUpdated);

7. Refer to the below code and predict the output:

String query="SELECT customer_name, request_status,cab_number,address_of_pickup,date_of_request FROM cab_request WHERE request_id=?";
  try{
   PreparedStatement pstmt= con.prepareStatement(query);
   pstmt.setInt(1, requestId);
   ResultSet result=pstmt.executeQuery(query);
 if(result.next())
   {
    System.out.println("Name of The Customer: "+result.getString(1));
}}
catch(SQLException se){
System.out.println(se.getMessage());
}

1). No error
2). Compilation error. Not all variables bound
3). Runtime error. Not all variables bound
4). None of the above
Solution :
option [3] is correct

8.Select the true statements about JDBC transactions:

1). A transaction is a set of successfully executed statements in the database
2). A transaction is finished when commit() or rollback() is called on the Connection object
3). JDBC Connection is in auto-commit mode, which it is by default, every SQL statement is 
committed to the database upon its completion.
4). A transaction is a set of actions to be carried out as a single, atomic action
Solution :
option [3,4] are correct

9.Consider the following code and predict the output :

String sql = "UPDATE ShowDetails SET AvSeats=? WHERE ShowId=?";
  preStatement = con.prepareStatement(sql);
  preStatement.setInt(1, 5);
  preStatement.setString(2, "S102");
  preStatement.executeQuery();

1). Compilation error as executeQuery is used to execute a DML statement
2). Runtime error as executeQuery is used to execute a DML statement
3). No error. Table gets updated
4). No error but table does not get updated
Solution :
option [3] is correct

10.Select the true statements from the following:

1). The classes which implement the interfaces in java.sql package are in rt.jar file, 
which you get along with jdk installation
2). The classes which implement the interfaces in java.sql package are in the jar file 
which the database vendor provides
3). Classes in ojdbc.jar file have been creaetd by the datbaase driver developer
4). Classes in ojdbc.jar file have been creaetd by the developers of Java
Solution :
option [2,3] are correct

11.Consider the following stored procedure and identify the JDBC interfaces which can be used 
to call this stored procedure.

CREATE OR REPLACE FUNCTION addNumbers(num1 NUMBER ,num2 NUMBER) RETURN NUMBER AS
BEGIN
RETURN (num1+num2);
END;
/

1). Statement
2). PreparedStatement
3). CallableStatement
4). ResultSet
Solution :
option [3] is correct


12.Consider the following code and answer the true statements:

String query="SELECT customer_name, request_status,cab_number,address_of_pickup,date_of_request FROM cab_request WHERE request_id=?";
PreparedStatement pstmt= con.prepareStatement(query);

1). Method is called on the interface Connection
2). Method is called on the implementation class which is a child of the interface Connection
3). This implementation class name need not be known to us. It is a part of the jar file provided 
by the java language
4). This implementation class name need not be known to us. It is a part of the jar file provided 
by the database vendor
5). The implementation class name needs to be known because it has to be mentioned in the java code
Solution :
option [2,4] are correct

13.

 SQL> desc cab_request
 Name                                      Null?    Type
 ----------------------------------------- -------- -------------
 REQUEST_ID                                         NUMBER
 CUSTOMER_NAME                                      VARCHAR2(20)
 PHONE_NUMBER                                       VARCHAR2(10)
 DATE_OF_REQUEST                                    DATE
 REQUEST_STATUS                                     VARCHAR2(12)
 CAB_NUMBER                                         VARCHAR2(15)
 ADDRESS_OF_PICKUP                                  VARCHAR2(50)
 PINCODE                                            NUMBER

Consider the following code and predict the output:

String sql="INSERT INTO cab_request VALUES(seq_request_id.nextval,?,?,sysdate,?,?,?,?)";
  try{
   PreparedStatement pstmt= con.prepareStatement(sql);
...//assume all other values have been set
 pstmt.setString(6, "411026");
pstmt.executeUpdate();

1). No error. Record gets inserted
2). Compilation error as string value is being assigned to a column of number datatype
3). Runtime error as string value is being assigned to a column of number datatype
4). No error for value 411026 as it is a number. But a value like "abc" would give runtime error 
"invalid number"
Solution :
option [1,4] are correct

14.Consider the following code and predict the output. Consider the table is empty:

String sql = "SELECT * FROM  ShowDetails";
  ShowBean showBean = null;
  List<ShowBean> shows = new ArrayList<ShowBean>();
  Statement statement = con.createStatement();
   rs = statement.executeQuery(sql);
   while (rs.next()) {
    showBean = new ShowBean();
    showBean.setShowId(rs.getString("ShowId"));
    showBean.setShowName(rs.getString("ShowName"));
    showBean.setLocation(rs.getString("Location"));
    showBean.setShowDate(rs.getDate("ShowDate").toString());
    showBean.setAvSeats(rs.getInt("AvSeats"));
    showBean.setPriceTicket(rs.getFloat("PriceTicket"));
    shows.add(showBean);

   }

1). ArrayList contains all the records from the table
2). ArrayList contains only the first record from the table
3). ArrayList contains only the last record from the table
4). Shows ArrayList is empty
Solution :
option [4] is correct
15.SQL> desc cab_request
 Name                                      Null?    Type
 ----------------------------------------- -------- ------------
 REQUEST_ID                                         NUMBER

What would the following code give as output ?
String sql="SELECT request_id FROM cab_request";
Statement stmt = con.createStatement();
ResultSet rSet = stmt.executeQuery(sql);
rSet.next();
System.out.println(rSet.getString(1));

Assume rows exist in the table:

1). Compilation error as datatype of column is number and java code has specified string
2). SQLException gets thrown as Oracle cannot convert number into string
3). No error. Column value is displayed
4). NumberFormatException get thrown
Solution :
option [3] is correct

16.
Select the  false statements regarding type 4 driver:

1). Type 4 driver is "native protocol, pure java" driver
2). Type 4 drivers are 100% Java compatible
3). Type 4 drivers uses Socket class to connect to the database
4). Extra software is required at client side or server side.
Solution :
option [4] is correct
17. Consider the following code and predict the output:
Assume table contains 5 records

public List<ShowBean> showAllMovies() throws BookingException{
  List<ShowBean> shows = new ArrayList<ShowBean>();
  String sql = "SELECT * FROM  ShowDetails";
  ShowBean showBean = null;
   Statement statement = con.createStatement();
  ResultSet rSet = statement.executeQuery(sql);
rSet.next();
   while (rSet.next()) {
    showBean = new ShowBean();
    showBean.setShowId(rSet.getString("ShowId"));
showBean.setShowName(rSet.getString("ShowName"));
shows.add(showBean);
}}

1). The arraylist contains all the records of the showdetails table
2). The arraylist contains all the records of the showdetails table except the last record
3). The arraylist contains all the records of the showdetails table except the first record
4). ArrayList is empty
Solution :
option [3] is correct

18.Consider the following stored procedure and identify the JDBC interfaces 
which can be used to call this stored procedure.

CREATE OR REPLACE PROCEDURE addNumbers(num1 NUMBER ,num2 NUMBER) AS
BEGIN
DBMS_OUTPUT.PUT_LINE(num1+num2);
END;
/

1). Statement
2). PreparedStatement
3). CallableStatement
4). ResultSet
Solution :
option [1,2,3] are correct

19.Consider the following code and predict the output.
Assume emp table exists in the database with 5 employee records

CREATE OR REPLACE PROCEDURE fetchDetails(dno dept.deptno%type) AS

ROW EMP%ROWTYPE;
BEGIN

SELECT * INTO ROW FROM EMP WHERE  deptno =dno;
DBMS_OUTPUT.PUT_LINE(ROW.EMPNO || ROW.ENAME ||ROW.DEPTNO);
END;
/

1). No error at both compilation and execution time.
2). Error: exact fetch returns more than requested number of rows is displayed during procedure 
compilation time
3). Error: exact fetch returns more than requested number of rows is displayed during procedure call
4). Procedure is executed and displays correct output
Solution :
option [3] is correct

20.Consider the following code and guess the output:

String sql="SELECT request_id FROM cab_request";
Statement stmt = con.createStatement();
ResultSet rSet = stmt.executeQuery(sql);
  
   rSet.next();
   rSet.getString(1);
    rSet.getString(1);
   System.out.println(rSet.getString(1));

1). Compilation error as rs.getString(1) is written more than once
2). No error. 1st row, 1st column value is printed once
3). No error. 1st row, 1st column value is printed thrice
4). SQLException as the same column value is being read more than once
Solution :
option [2] is correct

1.
The getParameter() method belongs to _______.           

1). Servlet
2). ServletRequest
3). ServletResponse
4). All of the above
Solution :
option [2] is correct

2.Given:

 i. load the servlet class
ii. init()
iii. destroy()
iv. service()
 v. instantiate 

Life cycle of Servlet, arrange it in proper order of execution.   

1). i, ii, iv, iii, v
2). i, v, ii, iv,iii
3). v, i, ii, iv,iii
4). i,v,iv,ii,iii
Solution :
option [2] is correct

3.What does the following code do? 

<FORM action="/EchoServlet" ENCTYPE="multipart/form-data" method="post">
       .................. 
<INPUT name="file" type="file">

1). Allows to upload file of any type
2). Allows to download file of any type
3). Allows to select a file type
4).  All of the above
Solution :
option [1] is correct

4.Fill in the blanks to complete following:

public class DemoServlet extends HttpServlet {
  public void doGet(HttpServletRequest req, HttpServletResponse res)
                      throws ServletException, IOException {
       res.setContentType("text/plain");
        ___________ out = res.getWriter();
        Enumeration headernames = req.getHeaderNames();
        while (headernames.___________) {
              String name = (String) headernames.nextElement();
              String value = req.________
              if (value != null) 
                  out.println(name + ": " + value);
         }
  }

1). PrintWriter, hasMoreElements();, getHeader(name);
2). getRemoteHost();,getRemoteAddr();,getRemoteAddres();
3). StringBuffer, hasNextElement(), getValue()
4). PrintWriter, hasNext();, getParameter(name);
Solution :
option [1] is correct

5.The HTTP request headers 'accept' specifies ______.          

1). Information about client software
2). MIME types that client accepts
3).  language(s) that client can receive
4). encoding format that client can use
Solution :
option [2] is correct

6.When using HTML forms which of the folowing is true for POST method?  

1). POST allows users to bookmark URLs with parameters. 
2). The POST method should not be used when large amount of data needs to be transferred
3). POST allows secure data transmission over the http method.
4). POST method sends data as payload, in the body of the request
Solution :
option [4] is correct

7.Match the following: 

a.getParameter()                     
b.getParameterNames()           
c.getParameterValues()          

i. String[]
ii. String
iii. Enumarator

1). a.i
b.ii
c.iii
2). a.ii
b.i
c.iii
3). a.ii
b.iii
c.i
4). a.i
b.iii
c.ii
Solution :
option [3] is correct

8. Which of the following methods in an HttpServlet should be overridden if required?

1)init()
2)service(HttpServletRequest,HttpServletResponse)
3)destroy()
4)doGet(HttpServletRequest,HttpServletResponse)        

1). 1,2,3
2). 1,3,4
3). 2,3,4
4). 1,2,4
Solution :
option [2] is correct

9._____ method returns the extra path information translated to a real file system path.         

1). HttpServletRequest.getPathTranslated( ) 
2). HttpServletRequest.getPathInfo( )
3). HttpServletRequest.getParameterValues
4). None of the above
Solution :
option [1] is correct
Attempted :

10.
Which is the correct annotation to define a servlet initialization parameter?        

1). @WebServlet(
  urlPatterns = { "/DemoServlet" }, 
  initParamaters = { 
    @WebInitParam( name = "length", value = "10"), 
    @WebInitParam(name = "breadth", value = "20")
  })

1.
Consider the following method cookie.setValue (String newvalue);
Which of the following are valid values for a cookie?          

1). IGATE Global Solutions
2). guest@igate.com
3). (IGATE)
4). IGATE
Solution :
option [4] is correct
2.What does the method getSession (true) do?          

1). It will return session object if a session exists
2). It will create a new session object if a session does not exist
3). It will return null if a session does not exist
4). It will always create a new session object irrespective of whether a session exists or not
Solution :
option [1,2] are correct
3.Which of the following constructor/method is the valid way of creating a new cookie?    

1). Cookie (String name, String value)
2). Cookie (String name)
3). Cookie (String value)
4). addCookie (Cookie cookie)
Solution :
option [1] is correct
4.
Which of the session tracking method works only for a sequence of dynamically generated forms?

1). URL Rewriting
2). Hidden Form Fields 
3). Cookie
4). User Authentication 
Solution :
option [2] is correct

5.
Given:

getServletContext().setAttribute("name","igatepatni");

What is the proper syntax to retriev 'name' attribute in another servlet? 

1). String name;
name=application.getAttribute("name");

2). String name;
name=getServletContext().getAttribute("name")

3). String name;
name=(String)getServletContext().setAttribute("name")

4). Any of the above

Solution :
option [3] is correct

6.
Which of the following are HttpSession methods?       

1). getSessionId()
2). getMaxInactiveInterval()
3). invalidate()
4). isNew()
Solution :
option [2,3,4] are correct

7.Which of the following are true about session management using servlets?        

1). URL Rewriting leads to network traffic 
2). URL Rewriting can be disabled by client
3). HttpSession  object by default uses cookies to manage session
4). cookies are stored on server-side hence secure
Solution :
option [1,3] are correct

8.Which of the following are true about Session timeout?

1. Session time out specified in web.xml is in minutes
2. Session time out specified programmatically is in seconds 

1). Both 1 & 2
2). Only 1
3). Only 2
4). None of these
Solution :
option [1] is correct

9.Fill in the blank in the following code snippet that retrieves all the session data:

HttpSession session = request.getSession(); 
Enumeration enum = session._____________
while(enum.hasMoreElements()){
   String name = (String) enum.nextElement();
   out.println(name + ":" + session.____________ + "<BR>");
}

1). getAttributeNames( ); getAttributeName( )
2). getAttributeNames( ); getAttribute(name)
3). getValueNames( ); getValue( )
4). getValueNames( ); getValue(name)
Solution :
option [2] is correct

10.The extra information included in the URL in case of URL rewriting can be in the form of:          

1). extra path information
2). additional parameters
3). server specific URL
4). All of the above
Solution :
option [4] is correct




1.Given:

public class MyFilter   ____1____  Filter
{

  public void init(____2____)
  {
  }

  public void doFilter(___3___,____4___,____5___)
  {
  }

  public void destroy()
  {
  }
}


a. extends
b. implements
c. FilterConfig
d. ServletConfig
e. ServletRequest
f. HttpServletRequest
g. ServletResponse
h. HttpServletResponse
i. FilterChain
j. SevletChain

Which of the following match properly completes the syntax of above code snippet?      

1). 1.a
2.d
3.f
4.h
5.i

2). 1.b
2.c
3.f
4.h
5.j

3). 1.b
2.c
3.e
4.g
5.i

4). 1.b
2.d
3.e
4.g
5.j

Solution :
option [3] is correct
Attempted :

2.To invoke a web components available on the server you must use ___________ object.          

1). ServletContext
2). RequestDispatcher
3). Session
4). ServletRequest
Solution :
option [2] is correc

3.
 Which of the following statements are false about a ServletContext instance?           

1). It is ideal for placing resources that need to be used by many different parts of a Web Application 
during any given time.

2). Objects bound to a ServletContext object will not be garbage collected until the ServletContext is 
removed from use, usually when the Web Application is turned off or restarted. 

3). Placing large amounts of unused objects in application scope does not tax a server's resources.

4). There can exist multiple ServletContexts for one web application

Solution :
option [3,4] are correct

4.
How to maintain global time out for all sessions?

1). HttpSession.logout(time)
2). HttpSession.setInterval(time)
3). HttpSession.setMaxInactiveInterval(time)
4). HttpSession.setInactiveInterval(time)
Solution :
option [3] is correct

5. What is wrong with the following code?

public void doFilter(ServletRequest req, ServletResponse, res,
FilterChain chain)
throws ServletException, IOException {
chain.doFilter(req, res);
HttpServletRequest request = (HttpServletRequest)req;
HttpSession session = request.getSession();
if (session.getAttribute("login") == null) {
session.setAttribute("login"”, new Login());
}
}

1). The doFilter() method signature is incorrect; it should take HttpServletRequest and HttpServletResponse.
2). The doFilter() method should also throw FilterException
3). The call to chain.doFilter(req, res) should be this: doFilter(req, res, chain).
4). Accessing the request after chain.doFilter() results in an IllegalState-Exception
5). Nothing is wrong with this filter.
Solution :
option [3] is correct

6.A servlet can be accessed in two different ways: via a regular HTTP request from a client, 
or via a javax.servlet.RequestDispatcher. Which of the following statements is correct?             

1). A dispatched request does not contain any request parameters (unless the calling 
     servlet explicitly includes them). 
2). There is no difference between the two options; the request dispatcher initiates 
     a new client request.
3). A request dispatched via RequestDispatcher usually shares the request parameters 
     of the original request.
4). A RequestDispatcher can access Servlets and resources that are not directly 
     accessible via a client request.
Solution :
option [3,4] are correct

7.Which of the following statements are true for a Servlet Filter?          

1). One filter can be associated with only one servlet
2). One filter can be associated with more than one servlet
3). The order of elements in web.xml should be filter, filter-mapping, servlet & servlet-mapping
4). The order of elements in web.xml should be servlet, servlet-mapping, filter, filter-mapping
Solution :
option [2,3] are correct

8.Q. Which of the following method of ServletContext returns a servlet wrapped with a RequestDispatcher object?

1). getNamedDispatcher()
2). getRequestDispatcher()
3). getServletDispatcher()
4). getDispatcher()
Solution :
option [1] is correct

9.Which of the following is not a lifecycle method of a Servlet Filter?          

1). init( )
2). service( )
3). doFilter( )
4). destroy( )
Solution :
option [2] is correct

10.Which of the given method is used to set the age of cookie?

1). setAge()
2). setMaxInterval()
3). setMaxAge()
4). setValue()
Solution :
option [3] is correct












1.When testing an error flow, what test would you write?

1). public void testErrorCase() throws Exception
     {
     methodToTest(); 
     // Asserts here }

2). public void testErrorCase(){ try{ 
     methodToTest(); 
     }
     catch (Exception expected)
     { 
     // Asserts her 
     } 
     }

3). public void testErrorCase(){ 
     try{ 
     methodToTest();  
     fail("Should not reach this point")
     catch (Exception expected)
     {  
     // Asserts here 
     } 
     }

4). None of the above
Solution :3

Given:
2)
1. class Crivitch {
2. public static void main(String [] args) {
3. int x = 0;
4. // insert code here
5. do { } while (x++ < y);
6. System.out.println(x);
7. }
8. }

Which statement, inserted at line 4, produces the output 12?

1). int y = 10;
2). int y = 11;
3). int y = 12;
4). int y = 13;
Solution :
option [2] is correct
Attempted :
option [2] is attempted



3.
